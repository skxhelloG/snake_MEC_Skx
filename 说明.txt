Turbo C 2.0我没使用过，这个是实训时用的，只了解几个简单基本的操作，对Turbo c感兴趣的话自行搜索学习。
使用方法：将下载的压缩包解压后有两个文件夹两个文件，双击Turbo C 2.0.vbs文件会出现蓝色小窗口。
准备工作：将.c文件复制到DISK_C\TC20\...的目录下
在蓝色窗口，按ALT+F打开一个菜单，在Load处回车两次，此时显示TC20文件下的文件目录和一些文件，
找到刚才的.c回车，将代码加载到小窗口(ALT+enter可以扩大到整个屏幕，退出是一样的，
可能会弹出一个窗口，此时退出，若想放到屏幕就选择“应用”，继续修改，不会对你的电脑有什么太大影响)
ALT+C编译下，ALT+R运行。

说明:
方向：w，a，s，d
加速：9
减速：3 （刚开始最慢，减速无用）
暂停：空格


doublesnakeTC.c说明：
1、思考：
	1）当不输入时，蛇1和蛇2的移动方向是互不影响的，所以就需要：两组表示移动方向的、互不影响的字符(比如蛇1的方向字符wasd，
	蛇2的方向字符8456(字符型)，当不输入时蛇1的方向字符为wasd的一种，蛇2的是8456中的一种，当输入wasd时，不能改变蛇2的方向字符，
	同理，反之也得成立；输入这8个字符外的其他，不能对任意一种有改变)；由于单蛇程序的基础，
	只需要类似的增加一个处理第二条蛇的方向字符的函数就能实现，
	与此同时，主函数里的方向字符增加一个，调用上述所说的新增函数，就能时刻准确得到新蛇的方向字符。
	2）单蛇程序中，设置了‘9’，‘3’这两个加速减速键。实质上是依情况调用不同参数的延时函数(delay)，
	仔细思考后觉得双蛇系统：理论上速度应该可以不一样，但是实际上，考虑实际问题，
	我想做的双蛇程序是在我的计算机里运行的，计算机只有一台，一旦某条蛇增加了延时的时间，
	另一条必然受到影响。而理论上的速度不同时因为控制每条蛇的人不同，说白了，
	同一个游戏一个人不可能同时用一个手机/电脑玩两条蛇。所以改变速度的函数不能存在了。
	3）单蛇程序中，我用一个大小为整个蛇能活动的区域的整形数组，存储蛇头经过的下标，使用该方式定位蛇尾。
	双蛇系统继续沿用该方法：既然如此，就需要新的一组追踪蛇头蛇尾下标的全局变量。
	刚开始时，想着可不可以，两条蛇用同一个上述所说的“追踪数组”完成对两组蛇头蛇尾的定位，
	蛇1头尾的定位工作从“追踪数组”下标最小的位置开始；蛇2头尾的定位工作从“追踪数组”下标中间的位置开始。
	我还觉得“真真是天衣无缝”。  直接说这种方式的错误吧：极端情况下，蛇2一直不吃食物，它就不吃，食物都让蛇1吃了，
	那出现的问题是，蛇1每次吃食物时，蛇1的尾的下标都不变，那在：“追踪数组”中对应的位置就不变，蛇1头是一直在变的。
	而蛇2的因为不吃食物，头尾都移动，导致蛇1 的尾与蛇2 的之间的数组空间越来越小，最后导致冲突。 
	最后解决方法：(呵呵)直接重新来一套新的“追踪数组”。
	4）问题：设情况如下
		1：蛇1向下运行到(x-1, y)，蛇2向左运动到(x, y+1);下一次移动后，理论上同时移动到(x, y )。请思考：该如何判断谁撞到了谁？
		2：相似情况，蛇1(头)向左移动到(x, y-1),蛇2的尾向下运行到(x-1, y)。下一次移动后，理论上同时移动到(x, y )。
		     请思考：该如何判断谁撞到了谁？
	解释：      在“宏观”上，蛇1和蛇2是同时到达(x, y)的，但在“微观”上，一个时间颗粒计算机只能做一个操作，所以实际上，
	               一定是某一条蛇先到了(x, y)，谁先到的具体操作是在移动函数(完成两条蛇的移动)里确定的。
	解决办法：其实很简单。不论在移动函数中哪条蛇先移动，比如蛇1先移动，那问题一的情况判定蛇1 先到，是蛇2撞了。
	                 问题二的情况，因为蛇1先移动，判定是蛇1撞了。若问题二的另一种情况是：蛇1和蛇2的位置交换，此时的情况是蛇1先移动，
	                 程序会判定蛇2没有死，游戏是继续的。
	总结：公平的判定方法。
	5）食物设定三种食物，代表的分数不同。最初随机5个，吃完再随机创建5个。方法：对创建一个食物的5次循环。
2、代码过程
基本是在单蛇程序的基础上修改，在此不赘述。


最后：编码格式UTF-8。